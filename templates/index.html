<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Query Oriented Data Cleaning</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='index_css.css') }}">
</head>

<body>
    <div class="container">
        <h1>Query Oriented Data Cleaning</h1>
        <div id="question-container"></div>
        <p id="question-count"></p>
        <button id="index-yes-btn" class="action-btn">Yes</button>
        <button id="index-no-btn" class="action-btn">No</button>
        <button id="index-back-btn" class="action-btn">Back</button>
        <button id="index-find-missing-btn" class="action-btn" onclick="window.location.href='/find_missing_values'">Find Missing Data Values</button>
        <button id="find-missing-yes-btn" class="action-btn">Provide Answer</button>
        <button id="find-missing-no-btn" class="action-btn">Next Question</button>
        <button id="find-missing-back-btn" class="action-btn">Back</button>
        <button id="show-flagged-values-btn" class="action-btn">Show Flagged Values Question</button>
        <button id="show-flagged-values-no-btn" class="action-btn">Next Question</button>
        <button id="show-flagged-values-back-btn" class="action-btn">Back</button>
        <button id="submit-answer-btn">Submit Answer</button>
    </div>
    <div id="queryModal" class="modal">
        <div class="modal-content">
            <span id="closeModal" class="close">&times;</span>
            <!-- <label>Provide an answer to the current question:</label> -->
            <p id="datatypeMessageContainer" style="color: rgb(0, 0, 0); margin-top: 35px;"></p>
            <input type="text" id="user-query-input" />
            <p id="error-message-container" class="error-message" style="display: none;"></p>
            <button id="submit-query-btn">Submit Your Answer</button>
        </div>
    </div>

    <!-- From here is the dialog box for index Yes button-->
<div id="dialog" class="dialog" style="display: none;">
    <button id="closeDialog" class="close-dialog">X</button>
    <div class="row">
        <span class="column-name" id="mainColumnName">Column Name</span>
        <span class="default-value" id="mainDefaultValue">Default Value</span>
        <button class="modify-btn yes-btn">Yes</button>
        <button class="modify-btn no-btn">No</button>
        <input type="text" id="mainInputField" class="input-field" data-type="{{ mainColumnDatatype }}" placeholder="Please Enter the Correct Value for Main Column" title="Enter the new value for the main column here" style="display: none;">
        <div id="mainInputError" class="input-error-message">Cannot be empty</div>
    </div>
    <div class="row">
        <span class="column-name" id="relatedColumnName">Related Column Name</span>
        <span class="default-value" id="relatedDefaultValue">Related Default Value</span>
        <button class="modify-btn yes-btn">Yes</button>
        <button class="modify-btn no-btn">No</button>
        <input type="text" id="relatedInputField" class="input-field" data-type="{{ relatedColumnDatatype }}" placeholder="Please Enter the Correct Value for Related Column" title="Enter the new value for the related column here" style="display: none;">
        <div id="relatedInputError" class="input-error-message">Cannot be empty</div>
    </div>
    
    <button id="submitAnswer">Submit Yes Answer</button>
</div>
<div id="overlay" class="overlay"></div>
<div class="row" id="mainRow"><!-- Content for the main column --></div>
<div class="row" id="relatedRow"><!-- Content for the related column --></div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
        
        let displayedRowIdMissing; // Variable to store the displayed row ID for missing data questions
        let currentQuestionIndex = 0;
        let displayedRowId; // Variable to store the displayed row ID
        var preRenderedQuestions = {{ pre_rendered_questions | safe }};
        
        var generatedQueries = [];
        var currentUrl = window.location.href; // Get the current URL
        let totalQuestions = preRenderedQuestions.length;
        const inputField = document.getElementById('user-query-input');
        const submitQueryBtn = document.getElementById('submit-query-btn');
        const closeModalBtn = document.getElementById('closeModal');
        const modal = document.getElementById('queryModal');
        const userQueryInput = document.getElementById('user-query-input');

        closeModalBtn.addEventListener('click', function() {
        modal.style.display = 'none'; 
        userQueryInput.value = ''; 
        });

        const questionContainer = document.getElementById('question-container');
        const questionCount = document.getElementById('question-count');

        // Select buttons based on the current URL
        const yesBtn = document.getElementById('index-yes-btn');
        const noBtn = document.getElementById('index-no-btn');
        const backBtn = document.getElementById('index-back-btn');
        const findMissingBtn = document.getElementById('index-find-missing-btn');

        // Select buttons for the find_missing_values page
        const findMissingYesBtn = document.getElementById('find-missing-yes-btn');
        const findMissingNoBtn = document.getElementById('find-missing-no-btn');
        const findMissingBackBtn = document.getElementById('find-missing-back-btn');

        // Select buttons for the show_flagged_values page
        const flaggedValue = document.getElementById('show-flagged-values-btn');
        const flaggedValuesnoBtn = document.getElementById('show-flagged-values-no-btn');
        const flaggedValuesbackBtn = document.getElementById('show-flagged-values-back-btn');
        const submitAnswerBtn = document.getElementById('submit-answer-btn');

        // Check if on the find_missing_values page
        if (currentUrl.includes('/find_missing_values')) {
            // Hide buttons on the index page
            yesBtn.style.display = 'none';
            noBtn.style.display = 'none';
            backBtn.style.display = 'none';
            findMissingBtn.style.display = 'none';
            submitAnswerBtn.style.display = 'none';

            // Show buttons on the find_missing_values page
            findMissingYesBtn.style.display = 'inline-block';
            findMissingNoBtn.style.display = 'inline-block';
            findMissingBackBtn.style.display = 'inline-block';
            flaggedValuesnoBtn.style.display = 'none';
            flaggedValuesbackBtn.style.display = 'none';

        } else {
            // Show buttons on the index page
            yesBtn.style.display = 'inline-block';
            noBtn.style.display = 'inline-block';
            backBtn.style.display = 'inline-block';
            findMissingBtn.style.display = 'inline-block';

            // Hide buttons on the find_missing_values page
            findMissingYesBtn.style.display = 'none';
            findMissingNoBtn.style.display = 'none';
            findMissingBackBtn.style.display = 'none';
            submitAnswerBtn.style.display = 'none';
            flaggedValuesnoBtn.style.display = 'none';
            flaggedValuesbackBtn.style.display = 'none';
        }

        // Function to update the cursor style of the submit button
function updateSubmitButtonCursor() {
        if (inputField.value.trim() === '') {
            submitQueryBtn.classList.add('cursor-not-allowed');
            submitQueryBtn.disabled = true; // Optionally disable the button
        } else {
            submitQueryBtn.classList.remove('cursor-not-allowed');
            submitQueryBtn.disabled = false; // Optionally enable the button
        }
    }

    // Initial check in case there's already text in the input field when the page loads
updateSubmitButtonCursor();
    // Event listener to check input field's value on keyup
inputField.addEventListener('keyup', function () {
        updateSubmitButtonCursor();
    });

// Add an event listener to clear the error message when the user starts typing
inputField.addEventListener('input', function () {
    const errorMessageContainer = document.getElementById('error-message-container');
    errorMessageContainer.style.display = 'none';
    inputField.classList.remove('error');
});
//for missing page
document.getElementById('submit-query-btn').addEventListener('click', function(event) {
    event.preventDefault();
    
    // Reintegrate the error message container handling
    const errorMessageContainer = document.getElementById('error-message-container');
    errorMessageContainer.style.display = 'none'; // Hide any previous error messages
    userQueryInput.classList.remove('error'); 

    const userQuery = userQueryInput.value.trim();
    const currentQuestion = preRenderedQuestions[currentQuestionIndex];
    const expectedDatatype = currentQuestion.data.datatype;

    if (validateUserInput(userQuery, expectedDatatype)) {
        const dataToSend = {
            rowId: currentQuestion.data.row_id,
            mainColumn: currentQuestion.data?.mainColumn,
            relatedColumn: currentQuestion.data?.relatedColumn,
            answer: userQuery
        };

        sendDataToServer(dataToSend)
        .then(() => {
            closeModal(); // Close the modal after successful submission
            displayNextUnansweredQuestion(); // Adjusted to use the custom function for displaying the next question
        })
        .catch(error => {
            // Display error message in UI
            errorMessageContainer.innerText = error.message;
            errorMessageContainer.style.display = 'block';
            userQueryInput.classList.add('error');
            userQueryInput.value = ''; // Clear the input field
            userQueryInput.focus(); // Focus on the input field for the user to correct the input
        });
    } else {
        // Display error message for invalid input
        displayErrorMessage(`Invalid input. Please enter a valid ${expectedDatatype}.`);
    }
});

function displayNextUnansweredQuestion() {
    let nextIndex = currentQuestionIndex + 1; // Start searching from the next question
    while (nextIndex < totalQuestions && preRenderedQuestions[nextIndex].answered) {
        nextIndex++; // Skip already answered questions
    }

    if (nextIndex < totalQuestions) {
        currentQuestionIndex = nextIndex; // Update the current index to the next unanswered question
        displayQuestion(); // Display the next unanswered question
    } else {
        // If no more unanswered questions are found
        handleAllQuestionsAnswered();
    }
}

function displayErrorMessage(message) {
    const errorMessageContainer = document.getElementById('error-message-container');
    errorMessageContainer.innerText = message;
    errorMessageContainer.style.display = 'block';
    inputField.classList.add('error');
    inputField.value = ''; // Clear the input field
    inputField.focus(); // Focus on the input field for user to correct the input

    // Add a class to animate the input field
    inputField.classList.add('input-error-animation');
    // Remove the class after the animation completes to allow it to be triggered again if needed
    setTimeout(() => inputField.classList.remove('input-error-animation'), 600);
}

// Function to send data to the server
function sendDataToServer(dataToSend) {
    return fetch('/process_answers', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(dataToSend),
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Network response was not ok. Status: ' + response.status);
        }
        return response.json();
    })
    .then(data => {
        if (data.status === "success") {
            // Mark the current question as answered
            preRenderedQuestions[currentQuestionIndex].answered = true;
        } else {
            throw new Error(data.message);
        }
    })
    .catch(error => {
        console.error('Fetch error:', error);
        throw error; // Rethrow the error to be handled in the caller function
    });
}

function closeModal() {
    const queryModal = document.getElementById('queryModal');
    const dialogModal = document.getElementById('dialog');
    const overlay = document.getElementById('overlay');

    if (queryModal) {
        queryModal.style.display = 'none';
    }

    if (dialogModal) {
        dialogModal.style.display = 'none';
    }

    if (overlay) {
        overlay.classList.remove('active');
    }
    document.getElementById('mainInputField').value = '';
    document.getElementById('mainInputField').style.display = 'none';
    document.getElementById('relatedInputField').value = '';
    document.getElementById('relatedInputField').style.display = 'none';
    }

function showQuestionModal() {
    // Set up the submit query when showing the modal
    setUpSubmitQuery();
    modal.style.display = 'block';
}

function displayQuestion(updatedQuestionIndex = currentQuestionIndex) {
    // If updatedQuestionIndex is provided, use it; otherwise, use currentQuestionIndex
    const questionIndex = updatedQuestionIndex !== undefined ? updatedQuestionIndex : currentQuestionIndex;
  
    // Skip answered questions
    while (questionIndex < totalQuestions && preRenderedQuestions[questionIndex].answered) {
        questionIndex++;
    }

    if (questionIndex < totalQuestions) {
        const currentQuestion = preRenderedQuestions[questionIndex];
        console.log('Current question object:', currentQuestion);
        // Check if the data property exists on the current question
        if (currentQuestion.data) {
            console.log('Current Question Data:', currentQuestion.data);

            const datatype = currentQuestion.data.datatype || "appropriate";
            const mainColumn = currentQuestion.data.mainColumn; // Extracted mainColumn
            const relatedColumn = currentQuestion.data.relatedColumn; // Extracted relatedColumn

            console.log('Datatype:', datatype);
            console.log('Main Column:', mainColumn); // Log the extracted mainColumn
            console.log('Related Column:', relatedColumn); // Log the extracted relatedColumn
        } else {
            // If currentQuestion.data is undefined, handle the error or initialize it
            console.error('Current Question Data is undefined.');
            // Initialize currentQuestion.data or handle the lack of data appropriately
        }

        const datatype = currentQuestion.data && currentQuestion.data.datatype ? currentQuestion.data.datatype : "appropriate";
        console.log('Datatype:', datatype);
        const datatypeMessage = `The answer is expected to be in ${datatype} format.`;
        document.getElementById('datatypeMessageContainer').innerText = datatypeMessage;
        
        // Check if we are on the "find missing values" page and set displayedRowIdMissing
        if (currentUrl.includes('/find_missing_values')) {
            // Check if currentQuestion has a data property and a row_id within it
            if (currentQuestion.data && 'row_id' in currentQuestion.data) {
                displayedRowIdMissing = currentQuestion.data.row_id;
                console.log(`Currently Displayed Row ID (Missing Data): ${displayedRowIdMissing}`);
            } else {
                console.error('Row ID missing in question data for missing values page');
            }
        } else {
            // For other pages, use the existing method to set displayedRowId
            displayedRowId = currentQuestion.row_id;
            console.log(`Currently Displayed Row ID: ${displayedRowId}`);
        }

        const questionLabel = questionContainer.querySelector('label');

        // Check if the question label exists
        if (questionLabel) {
            if (currentQuestion.hasOwnProperty('question')) {
                // For flagged value questions
                questionLabel.textContent = formatQuestionText(currentQuestion.question);
            } else {
                // For regular questions (assuming 'message' field contains the question text)
                questionLabel.textContent = formatQuestionText(currentQuestion.message);
            }
        } else {
            // If the question label does not exist, create it
            questionContainer.innerHTML = `<label>${formatQuestionText(currentQuestion.message || currentQuestion.question)}</label>`;
        }

        // Add tooltip for rule violation text if it exists
        if (currentQuestion.hasOwnProperty('rule_violation') && currentQuestion.rule_violation) {
            const ruleViolationText = currentQuestion.rule_violation;
            const tooltip = document.createElement('img');
            tooltip.src = 'http://localhost/project/templates/info.png';
            tooltip.className = 'tooltip-icon';
            tooltip.alt = 'Info';
            tooltip.title = ruleViolationText; // Tooltip text
            const questionLabel = questionContainer.querySelector('label');
            questionLabel.appendChild(tooltip);
        }

        updateQuestionCount();
        // Ensure the submit button cursor and disabled state are updated for the new question
        updateSubmitButtonCursor();
    
        // Check if this is the last question
    if (currentQuestionIndex === totalQuestions - 1) {
            showLastQuestionNotification(); // Call a function to display a notification
        }
    
    } else {
        //alert('All questions answered. Submitting form...');
        handleAllQuestionsAnswered();
    }
}

function formatQuestionText(questionText) {
                return questionText.replace(/''/g, '_______');
            }

function updateQuestionCount() {
    const unansweredQuestions = preRenderedQuestions.filter(question => !question.answered).length;
    const currentQuestionNumber = preRenderedQuestions.slice(0, currentQuestionIndex).filter(question => !question.answered).length + 1; // Adjusted to reflect the current position

    questionCount.textContent = `Question ${currentQuestionNumber} of ${unansweredQuestions}`;
}

function submitAnswer() {
    
    const userQuery = userQueryInput.value.trim();
    const expectedDatatype = preRenderedQuestions[currentQuestionIndex].data.datatype;

    // Validate user input
    if (!validateUserInput(userQuery, expectedDatatype)) {
        displayErrorMessage(`Invalid input. Please enter a valid ${expectedDatatype}.`);
        return; // Prevent form submission
    }

    // If the input is valid, prepare the data for submission
    if (userQuery !== '') {
        const currentQuestion = preRenderedQuestions[currentQuestionIndex];
        const dataToSend = {
            rowId: currentQuestion.data.row_id,
            mainColumn: currentQuestion.data.mainColumn,
            relatedColumn: currentQuestion.data.relatedColumn,
            answer: userQuery
        };

        // Send the data to the server
        sendDataToServer(dataToSend, function (success) { // Pass a callback function for success
            if (success) {
                // Clear the input field only after successful submission
                userQueryInput.value = '';
                // Move to the next question or end the questionnaire
                currentQuestionIndex++;
                if (currentQuestionIndex < totalQuestions) {
                    displayQuestion();
                } else {
                    //alert('All questions answered. Submitting form...');
                    handleAllQuestionsAnswered();
                }
            }
        });
    }
}

// This function is called when the 'Yes' button is clicked on the index page
function answerYes_index() {
    modal.style.display = 'block'; // Show the modal
    // Add event listener to the close button of the modal
    closeModalBtn.addEventListener('click', function() {
        modal.style.display = 'none'; // Hide the modal
    });
}

function validateUserInput(input, datatype) {
    // Use regular expressions to test the input based on the expected datatype
    const regexPatterns = {
        'integer': /^\d+$/, // Matches a sequence of digits (no decimal)
        'float': /^\d+(\.\d+)?$/, // Matches a floating point number (integer part plus optional decimal part)
        'date': /^\d{4}-(\d{1,2})-(\d{1,2})$/, // Matches YYYY-M-D, YYYY-MM-DD, YYYY-M-DD, YYYY-MM-D
        'text': /^(?=.*[A-Za-z0-9])[A-Za-z0-9@.]+$/ // Requires at least one alphanumeric character, allows '@' and '.' for emails
    };

    // Check if the datatype is known and the pattern exists
    if (regexPatterns.hasOwnProperty(datatype)) {
        // Test the input against the corresponding regex pattern
        return regexPatterns[datatype].test(input);
    } else {
        // If the datatype is unknown, log an error and return false
        console.error(`Unknown datatype '${datatype}' for validation.`);
        return false;
    }
}
//for index page dialog box input field Function to validate input and apply animation if input is incorrect
function validateAndAnimateInput(inputField, errorContainer, datatype) {
    const isValid = validateUserInput(inputField.value.trim(), datatype);
    if (!isValid) {
        showError(inputField, errorContainer, `Value must be a ${datatype}.`);
        inputField.classList.add('input-shake');
        inputField.value = ''; // Clear the input field
        setTimeout(() => {
            inputField.classList.remove('input-shake');
        }, 820); // Remove the class after the animation ends, which is 0.82s
        return false;
    }
    hideError(inputField, errorContainer);
    return true;
}


//for index page dialog box input field
function applyVibrationAnimation(inputField) {
    inputField.classList.add('input-error');
    inputField.classList.add('input-error-animation');
    inputField.addEventListener('animationend', function() {
        inputField.classList.remove('input-error-animation'); // Remove the animation class at the end
    }, {once: true});
}

function findMissingPageAnswerYes() {
    modal.style.display = 'block';
    
}

// Function to update the database with the provided answer
function updateDatabaseWithAnswer(userQuery, currentQuestion) {
                const [_, rowId, mainColumn, relatedColumn] = currentQuestion.name.split('_');

                // Dynamically extract the relatedColumn from the question text
                const questionText = currentQuestion.message;
                const relatedColumnMatch = questionText.match(/The (.*?):/);
                const dynamicRelatedColumn = relatedColumnMatch ? relatedColumnMatch[1].trim() : null;

                const data = {
                    rowId: rowId,
                    mainColumn: mainColumn,
                    relatedColumn: dynamicRelatedColumn, // Use the dynamically extracted relatedColumn
                    answer: userQuery,
                };

                // Send a POST request to the server to process the answer and update the database
                fetch('/process_answers', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(data),
                })
                .then(response => response.json())
                .then(data => {
                    console.log(data);

                    // Increment the currentQuestionIndex and display the next question
                    currentQuestionIndex++;
                    if (currentQuestionIndex < totalQuestions) {
                        displayQuestion();
                    } else {
                        //alert('All questions answered. Submitting form...');
                        handleAllQuestionsAnswered();
                    }
                })
                .catch(error => console.error(error));
}

function findMissingPageAnswerNo() {
    currentQuestionIndex++;
    if (currentQuestionIndex < totalQuestions) {
        displayQuestion();
        console.log(`Missing Page Answer No : ${displayedRowIdMissing}`);
    } else {
        //alert('All questions answered. Submitting form...');
        handleAllQuestionsAnswered();
    }
}
            
function findMissingPageGoBack() {
    // Decrement index and skip answered questions
    do {
        currentQuestionIndex--;
    } while (currentQuestionIndex >= 0 && preRenderedQuestions[currentQuestionIndex].answered);

    if (currentQuestionIndex >= 0) {
        displayQuestion();
    } else {
        alert('No more previous questions.');
        currentQuestionIndex = 0; // Reset to the first question if needed
    }
}
                
function findMissingValues() {
                const filteredMissingQuestions = preRenderedQuestions.filter(question => {
                    const mainColumn = question.message.split("'")[1];
                    const mainColumnValue = row[mainColumn];
                    return mainColumnValue === '';
                });

                console.log('Filtered Missing Questions:', filteredMissingQuestions);

                totalQuestions = filteredMissingQuestions.length;

                if (totalQuestions > 0) {
                    currentQuestionIndex = 0;
                    preRenderedQuestions = filteredMissingQuestions;
                    findMissingBtn.disabled = true;
                    displayQuestion();
                } else {
                    questionContainer.innerHTML = '<p>No missing data questions found.</p>';
                    questionCount.textContent = '0 of 0';
                }

                updateGeneratedQueries();
            }
            
function showFlaggedValuesQuestions() {
    console.log('Show Flagged Values button clicked');
    // Make an AJAX request to fetch flagged values questions
    fetch('/show_flagged_values_questions', {
        method: 'GET',
        headers: {
            'Content-Type': 'application/json',
        },
    })
    .then(response => response.json())
    .then(data => {
        const flaggedValuesQuestions = data.questions;
        // Update the question container with flagged values questions
        questionContainer.innerHTML = ''; // Clear existing content
        // Iterate through flagged values questions and append to the question container
        flaggedValuesQuestions.forEach(question => {
            const questionElement = document.createElement('p');
            questionElement.textContent = question;
            questionContainer.appendChild(questionElement);
        });
        // Hide other buttons on the flagged values page
        yesBtn.style.display = 'none';
        noBtn.style.display = 'none';
        backBtn.style.display = 'none';
        findMissingBtn.style.display = 'none';
        findMissingYesBtn.style.display = 'none';
        findMissingNoBtn.style.display = 'none';
        findMissingBackBtn.style.display = 'none';
        submitAnswerBtn.style.display = 'inline-block';
    })
    .catch(error => console.error(error));
}

// Function to handle button clicks on the index page
function handleIndexPageButtonClick(buttonId) {
                if (buttonId === 'yes') {
                    answerYes_index();
                } else if (buttonId === 'no') {
                    answerNo_index();
                } else if (buttonId === 'back') {
                    goBack_index();
                }
            }

function handleFindMissingPageButtonClick(buttonId) {
            // Function for handling button clicks on the find_missing_values page
            if (buttonId === 'yes') {
                findMissingPageAnswerYes();
            } else if (buttonId === 'no') {
                findMissingPageAnswerNo();
            } else if (buttonId === 'back') {
                findMissingPageGoBack();
            }
        }
            
// Function to handle button click on the flagged values page
function handleFlaggedValuesButtonClick(buttonId) {
    if (buttonId === 'submit-answer') {
        console.log('Submitting flagged values answers');
    }
}

//Event listener for the 'Submit Answer' button on flagged values page
document.getElementById('submit-answer-btn').addEventListener('click', function () {
    console.log('Submit button clicked');
    handleFlaggedValuesButtonClick('submit-answer');
});

// Event listener for the 'Show Flagged Values' button
document.getElementById('show-flagged-values-btn').addEventListener('click', function() {
    fetch('/show_flagged_values_questions', {
        method: 'GET',
        headers: {
            'Content-Type': 'application/json',
        },
    })
    .then(response => response.json())
    .then(data => {
        // Update to use the correct structure for the questions
        const flaggedValuesQuestions = data.questions.map(question => ({
            question: question.question, // Assuming 'question' contains the question text
            rule_violation: question.rule_violation, // Rule violation text
            name: `flagged_value_question_${question.row_id}`, // Unique identifier for each question
            row_id: question.row_id // Row ID if available
        }));

        // Update preRenderedQuestions with the new data
        preRenderedQuestions = flaggedValuesQuestions;
        // Reset the current question index and display the first question
        currentQuestionIndex = 0;
        displayQuestion();
    })
    .catch(error => console.error(error));

    // Hide other buttons and show necessary ones for flagged values questions
    yesBtn.style.display = 'none';
    noBtn.style.display = 'none';
    backBtn.style.display = 'none';
    findMissingBtn.style.display = 'none';
    findMissingYesBtn.style.display = 'none';
    findMissingNoBtn.style.display = 'none';
    findMissingBackBtn.style.display = 'none';
    flaggedValue.style.display = 'none';

    flaggedValuesnoBtn.style.display = 'inline-block';
    flaggedValuesbackBtn.style.display = 'inline-block';
    submitAnswerBtn.style.display = 'inline-block';
});

//index page
function answerNo_index() {
    const currentQuestion = preRenderedQuestions[currentQuestionIndex];

    // Send a POST request to the server to log the current row ID
    fetch('/log_current_row_id', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ row_id: currentQuestion.row_id }),  // Pass the current question's row_id
    })
    .then(response => response.json())
    .then(data => {
        // Move to the next question
        currentQuestionIndex++;

        // Check if there are more questions before displaying
        if (currentQuestionIndex < totalQuestions) {
            displayQuestion();
        } else {
            //alert('All questions answered. Submitting form...');
            handleAllQuestionsAnswered();
        }
    })
    .catch(error => console.error(error));
}

//index page
function goBack_index() {
    let foundUnanswered = false;
    // Decrement currentQuestionIndex until an unanswered question is found or the beginning of the array is reached
    for (let i = currentQuestionIndex - 1; i >= 0; i--) {
        if (!preRenderedQuestions[i].answered) {
            currentQuestionIndex = i;
            foundUnanswered = true;
            break;
        }
    }

    // If an unanswered question is found, display it
    if (foundUnanswered) {
        displayQuestion();
    } else {
        // Optionally, handle the case where no previous unanswered questions are found
        alert("No more previous unanswered questions.");
    }
}

//index page
document.getElementById('index-yes-btn').addEventListener('click', function() {
    resetDialogState(); // Reset the dialog state every time it is opened
    const dialog = document.getElementById('dialog');
    const overlay = document.getElementById('overlay');

    const currentQuestion = preRenderedQuestions[currentQuestionIndex];
    if (currentQuestion) {
        const mainColumn = currentQuestion.mainColumn;
        const mainValue = currentQuestion.mainValue;
        const relatedColumn = currentQuestion.relatedColumn;
        const relatedValue = currentQuestion.relatedValue;

        const mainColumnDatatype = currentQuestion.mainColumnDatatype; // Fetch the datatype for the main column
        const relatedColumnDatatype = currentQuestion.relatedColumnDatatype; // Fetch the datatype for the related column

        // Update the dialog with the column names and default values
        updateDialog(mainColumn, mainValue, relatedColumn, relatedValue);

        // Update the tooltips with datatype information
        document.getElementById('mainInputField').setAttribute('title', `The expected answer is of ${mainColumnDatatype} datatype`);
        document.getElementById('relatedInputField').setAttribute('title', `The expected answer is of ${relatedColumnDatatype} datatype`);

        dialog.style.display = 'block';
        overlay.classList.add('active');
    } else {
        console.error('Current question or current question data is undefined:', currentQuestion);
    }
});

// Flag variables to keep track of whether 'Yes' or 'No' has been clicked
let yesClicked = false;
let noClicked = false;

//index page (dialog yes button)
document.querySelectorAll('.modify-btn.yes-btn').forEach(function(btn) {
    btn.addEventListener('click', function() {
        yesClicked = true;
        noClicked = false;
        // Determine which input field to show based on the parent row's ID
        let parentRow = this.parentElement; // Get the parent row of the clicked button

        // Only select the input field that is a child of this parent row
        let inputField = parentRow.querySelector('.input-field');

        // Display the relevant input field
        inputField.style.display = 'block';
        inputField.style.opacity = '0';
        setTimeout(function() {
            inputField.style.opacity = '1';
        }, 10); // Fade in effect
    });
});

//index page (dialog no button)
let noButtons = document.querySelectorAll('.no-btn');
noButtons.forEach(function(btn) {
    btn.addEventListener('click', function() {
        yesClicked = false; 
        noClicked = true;

        let parentRow = this.parentElement;
        let inputField = parentRow.querySelector('.input-field');
        let errorContainer = parentRow.querySelector('.input-error-message');

        console.log('No button clicked for row:', parentRow.id); // Debugging line
        console.log('Error container should be hidden:', errorContainer.id); // Debugging line

        // Hide the input field immediately
        inputField.style.display = 'none';
        
        // Hide the error message immediately
        errorContainer.style.display = 'none';
        console.log('Error container display after hiding:', errorContainer.style.display); // Debugging line
    });
});

//index page (dialog submit button)
document.getElementById('submitAnswer').addEventListener('click', function() {
    const mainInputField = document.getElementById('mainInputField');
    const relatedInputField = document.getElementById('relatedInputField');
    
    const mainInputError = document.getElementById('mainInputError');
    const relatedInputError = document.getElementById('relatedInputError');

    const mainColumnDatatype = preRenderedQuestions[currentQuestionIndex].mainColumnDatatype;
    const relatedColumnDatatype = preRenderedQuestions[currentQuestionIndex].relatedColumnDatatype;

    const mainDefaultValue = document.getElementById('mainDefaultValue').textContent;
    const relatedDefaultValue = document.getElementById('relatedDefaultValue').textContent;

    // Get the trimmed values of the input fields
    const mainFieldValue = mainInputField.value.trim();
    const relatedFieldValue = relatedInputField.value.trim();

    // Determine visibility of the input fields
    const mainFieldVisible = mainInputField.style.display !== 'none';
    const relatedFieldVisible = relatedInputField.style.display !== 'none';

    // Reset error states
    mainInputError.style.display = 'none';
    relatedInputError.style.display = 'none';

    let validationPassed = true;

        // Checkpoint 5: One field is visible and empty, and the other wasn't opened
    if ((mainFieldVisible && !mainFieldValue && !relatedFieldVisible) || (relatedFieldVisible && !relatedFieldValue && !mainFieldVisible)) {
        if (mainFieldVisible && !mainFieldValue) {
            mainInputError.style.display = 'block';
        }
        if (relatedFieldVisible && !relatedFieldValue) {
            relatedInputError.style.display = 'block';
        }
        return; // Prevent form submission
    }

    // Check if both fields are visible and have a value ; check point
    if (mainFieldVisible && !mainFieldValue && relatedFieldVisible && !relatedFieldValue) {
        // Both fields are visible but empty, show error message
        mainInputError.style.display = 'block';
        relatedInputError.style.display = 'block';
        return; // Prevent form submission
    }

    // Check the main input field
    if (mainInputField.style.display !== 'none' && !validateUserInput(mainInputField.value.trim(), preRenderedQuestions[currentQuestionIndex].mainColumnDatatype)) {
        showError(mainInputField, 'Value must be a ' + preRenderedQuestions[currentQuestionIndex].mainColumnDatatype + '.');
        mainInputField.value = ''; // Clear the input field
        validationPassed = false; // Set validation as failed
    } else {
        hideError(mainInputField);
    }

    // Check the related input field
    if (relatedInputField.style.display !== 'none' && !validateUserInput(relatedInputField.value.trim(), preRenderedQuestions[currentQuestionIndex].relatedColumnDatatype)) {
        showError(relatedInputField, 'Value must be a ' + preRenderedQuestions[currentQuestionIndex].relatedColumnDatatype + '.');
        relatedInputField.value = ''; // Clear the input field
        validationPassed = false; // Set validation as failed
    } else {
        hideError(relatedInputField);
    }

    // If validation fails, stop the function execution
    if (!validationPassed) return;
    
    // Decide which values to submit based on visibility and user interaction
    const mainValueToSubmit = mainFieldVisible && mainFieldValue ? mainFieldValue : mainDefaultValue;
    const relatedValueToSubmit = relatedFieldVisible && relatedFieldValue ? relatedFieldValue : relatedDefaultValue;

    // Prepare data to send
    const dataToSend = {
        rowId: displayedRowId, 
        mainValue: mainValueToSubmit,
        relatedValue: relatedValueToSubmit
    };

    // Perform validation to ensure at least one field has a value
    if (!mainFieldVisible && !relatedFieldVisible) {
        alert("Please provide an answer or close the dialog box.");
        return; // Prevent form submission or further processing
    }

    // Send the data to the server
    submitDialogData(dataToSend);
});

//index page dialog box reset
function resetDialogState() {
    // Clear input fields
    const mainInputField = document.getElementById('mainInputField');
    const relatedInputField = document.getElementById('relatedInputField');
    mainInputField.value = '';
    relatedInputField.value = '';
    
    // Hide input fields
    mainInputField.style.display = 'none';
    relatedInputField.style.display = 'none';

    // Reset error messages and hide them
    const mainInputError = document.getElementById('mainInputError');
    const relatedInputError = document.getElementById('relatedInputError');
    mainInputError.textContent = 'Cannot be empty';
    relatedInputError.textContent = 'Cannot be empty';
    mainInputError.style.display = 'none';
    relatedInputError.style.display = 'none';
    
    // Remove any error classes applied to input fields
    mainInputField.classList.remove('error-class'); // Replace 'error-class' with the actual class name used for errors
    relatedInputField.classList.remove('error-class');
}

// Function to show error message and apply shake animation
function showError(inputField, message) {
    let errorContainer = inputField.nextElementSibling; // Assumes the error container is the next sibling element
    errorContainer.textContent = message;
    errorContainer.style.display = 'block';
    inputField.classList.add('input-error-highlight', 'input-shake');
    setTimeout(() => {
        inputField.classList.remove('input-shake');
    }, 1000); // remove the class after the animation ends
}

// Function to hide error message
function hideError(inputField) {
    let errorContainer = inputField.nextElementSibling; // Assumes the error container is the next sibling element
    errorContainer.style.display = 'none';
    inputField.classList.remove('input-error-highlight');
}
//index page
function displayNextQuestionForIndexPage() {
    let foundUnanswered = false;
    // Increment currentQuestionIndex until an unanswered question is found or the end of the array is reached
    while (currentQuestionIndex + 1 < totalQuestions && preRenderedQuestions[currentQuestionIndex + 1].answered) {
        currentQuestionIndex++;
    }

    // Check if the next question is unanswered
    if (currentQuestionIndex + 1 < totalQuestions && !preRenderedQuestions[currentQuestionIndex + 1].answered) {
        currentQuestionIndex++;
        foundUnanswered = true;
    }

    // If an unanswered question is found, display it
    if (foundUnanswered) {
        displayQuestion();
    } else {
        // Handle case where all questions have been answered
        handleAllQuestionsAnswered();
    }
}

//index page
function submitDialogData(data) {
    // Fetch the column names and default values from the dialog display
    const mainColumn = document.getElementById('mainColumnName').textContent;
    const relatedColumn = document.getElementById('relatedColumnName').textContent;
    const mainDefaultValue = document.getElementById('mainDefaultValue').textContent;
    const relatedDefaultValue = document.getElementById('relatedDefaultValue').textContent;

    // Initialize the payload with rowId and column names
    const payload = {
        rowId: data.rowId,
        mainColumn: mainColumn,
        relatedColumn: relatedColumn,
        mainValue: (mainInputField.style.display !== 'none' && data.mainValue && data.mainValue.trim() !== '') ? data.mainValue.trim() : mainDefaultValue,
        relatedValue: (relatedInputField.style.display !== 'none' && data.relatedValue && data.relatedValue.trim() !== '') ? data.relatedValue.trim() : relatedDefaultValue,
    };

    console.debug('Sending data to server:', payload);

    // Make the POST request to the server endpoint
    fetch('/update_dialog_values', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Network response was not ok. Status: ' + response.status);
        }
        return response.json();
    })
    .then(data => {
        if(data.status === "success") {
            console.log('Updated values from server:', data.updatedValues);
            preRenderedQuestions[currentQuestionIndex].answered = true;
            // Iterate through all questions and update those that match the rowId
            preRenderedQuestions.forEach(question => {
                if (question.row_id === data.updatedValues.rowId) {
                    // Update the mainValue and relatedValue if they match the columns involved in the dialog
                    if (question.mainColumn === mainColumn) {
                        question.mainValue = data.updatedValues.mainValue;
                        question.message = question.message.replace(mainDefaultValue, data.updatedValues.mainValue);
                    }
                    if (question.relatedColumn === relatedColumn) {
                        question.relatedValue = data.updatedValues.relatedValue;
                        question.message = question.message.replace(relatedDefaultValue, data.updatedValues.relatedValue);
                    }
                }
            });

            // After updating, refresh the current question display or move to the next
            displayNextQuestionForIndexPage();
            closeModal();
        } else {
            console.error('Error updating values:', data.message);
        }
    })
    .catch(error => {
        console.error('Fetch error:', error);
    });
}

 //index page
function clearErrorState() {
    this.classList.remove('input-error');
    this.placeholder = this === mainInputField ? "Please Enter the Correct Value for Main Column" : "Please Enter the Correct Value for Related Column";
}

const mainInputField = document.getElementById('mainInputField');
const relatedInputField = document.getElementById('relatedInputField');

mainInputField.addEventListener('input', clearErrorState);
relatedInputField.addEventListener('input', clearErrorState);

function updateCurrentQuestion(updatedValues) {
    // Find the question in preRenderedQuestions by rowId and update its values
    const questionIndex = preRenderedQuestions.findIndex(question => question.row_id == updatedValues.rowId);
    if(questionIndex !== -1) {
        preRenderedQuestions[questionIndex].mainValue = updatedValues.mainValue;
        preRenderedQuestions[questionIndex].relatedValue = updatedValues.relatedValue;
    } else {
        console.error('Question not found in preRenderedQuestions:', updatedValues.rowId);
    }
}

function updateDisplayWithNewValues(updatedValues) {
    // Assuming 'question-container' is where the mainValue is displayed
    const mainValueDisplay = document.getElementById('mainColumnName');
    const relatedValueDisplay = document.getElementById('relatedColumnName');
    
    // Update the UI with the new values
    if (mainValueDisplay && updatedValues.mainValue) {
        mainValueDisplay.textContent = updatedValues.mainValue;
    }
    if (relatedValueDisplay && updatedValues.relatedValue) {
        relatedValueDisplay.textContent = updatedValues.relatedValue;
    }
}

function updateDialog(mainColumn, mainValue, relatedColumn, relatedValue) {
    // Update the content of the first row with mainColumn and mainValue
    document.getElementById('mainColumnName').textContent = mainColumn;
    document.getElementById('mainDefaultValue').textContent = mainValue;

    // Update the content of the second row with relatedColumn and relatedValue
    document.getElementById('relatedColumnName').textContent = relatedColumn;
    document.getElementById('relatedDefaultValue').textContent = relatedValue;

    // Add event listeners for Yes/No buttons in both rows
    const yesButtons = document.querySelectorAll('.yes-btn');
    const noButtons = document.querySelectorAll('.no-btn');

    yesButtons.forEach(button => button.addEventListener('click', handleYesClick));
    noButtons.forEach(button => button.addEventListener('click', handleNoClick));
}

//index page
function handleYesClick(event) {
    // Show the input field to enter the correct value in the related row
    const parentRow = event.target.closest('.row'); // Find the closest parent row of the clicked button
    const inputField = parentRow.querySelector('.input-field');
    inputField.style.display = 'block';
}

//index page
function handleNoClick(event) {
    // Find the closest parent row of the clicked button
    const parentRow = event.target.closest('.row');

    // Find the input field within this row
    const inputField = parentRow.querySelector('.input-field');

    // Check if the input field exists and hide it if so
    if (inputField) {
        inputField.style.display = 'none'; // Hide the input field

        // Optionally, you might also want to clear any value that was entered
        inputField.value = '';
    }
}

//index page ( Get input fields and error message containers)
    const mainInputError = document.getElementById('mainInputError');
    const relatedInputError = document.getElementById('relatedInputError');

// Reset error state when user starts typing in the input fields
    function resetErrorState(inputField, errorContainer) {
        inputField.classList.remove('input-error-highlight', 'input-shake');
        errorContainer.style.display = 'none';
    }

    mainInputField.addEventListener('input', function() {
        resetErrorState(mainInputField, mainInputError);
    });

    relatedInputField.addEventListener('input', function() {
        resetErrorState(relatedInputField, relatedInputError);
    });

// for index (Close dialog function updated to reset error states)
document.getElementById('closeDialog').addEventListener('click', function() {
    const dialog = document.getElementById('dialog');
    const overlay = document.getElementById('overlay');
    yesClicked = false;
    noClicked = false;
    
    // Hide the dialog and overlay
    dialog.style.display = 'none';
    overlay.classList.remove('active');

    // Call resetDialogState to reset the dialog state
    resetDialogState();
});


//index page
document.getElementById('index-no-btn').addEventListener('click', function () {
                handleIndexPageButtonClick('no');
            });
            
//index page
document.getElementById('index-back-btn').addEventListener('click', function () {
                handleIndexPageButtonClick('back');
            });

document.getElementById('show-flagged-values-no-btn').addEventListener('click', function () {
                currentQuestionIndex++;
                if (currentQuestionIndex < preRenderedQuestions.length) {
                    displayQuestion();
                } else {
                    alert('All questions answered.');
                }
            });
            
document.getElementById('show-flagged-values-back-btn').addEventListener('click', function () {
                currentQuestionIndex--;
                if (currentQuestionIndex >= 0) {
                    displayQuestion();
                } else {
                    alert('No previous questions.');
                    currentQuestionIndex = 0; // Reset to the first question
                }
            });

// Event listeners for find_missing_values page buttons
findMissingYesBtn.addEventListener('click', function () {
                handleFindMissingPageButtonClick('yes');
            });

findMissingNoBtn.addEventListener('click', function () {
                handleFindMissingPageButtonClick('no');
            });

findMissingBackBtn.addEventListener('click', function () {
                handleFindMissingPageButtonClick('back');
            });

function handleAllQuestionsAnswered() {
    // Close the modal and clear the input field
    closeModal();
    userQueryInput.value = '';

    // Hide all existing buttons
    const buttons = document.querySelectorAll('button');
    buttons.forEach(button => button.style.display = 'none');

    // Display a completion message
    questionContainer.innerHTML = '<p class="completion-message">Thank you! You have answered all the questions.</p>';

    // Create the "Take me back to the Home Page" button
    const homeButton = document.createElement('button');
    homeButton.textContent = 'Take me back to the Home Page';
    homeButton.id = 'home-page-button';
    homeButton.className = 'action-btn'; // Reuse the action-btn class for styling
    homeButton.onclick = function() { window.location.href = 'http://127.0.0.1:5500/templates/homepage.html'; };
    
    // Append the new button to the container
    document.querySelector('.container').appendChild(homeButton);
}

function showLastQuestionNotification() {
    const notificationContainer = document.createElement('div');
    notificationContainer.textContent = "This is the last question";
    notificationContainer.className = 'last-question-notification'; // Use the class instead of inline styles

    // Append this notification to the question container or any other suitable place in your DOM
    questionContainer.appendChild(notificationContainer);

    // Optionally, remove the notification after a few seconds
    setTimeout(() => {
        notificationContainer.remove();
    }, 5000); // Adjust the time as needed
}

if (totalQuestions > 0) {
    displayQuestion();
    } else {
        alert('No questions found.');
            }
});
    </script>
</body>
</html>