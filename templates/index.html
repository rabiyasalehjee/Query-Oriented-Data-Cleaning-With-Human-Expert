<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Query Oriented Data Cleaning</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='index_css.css') }}">
</head>

<body>
    <div class="container">
        <h1>Query Oriented Data Cleaning</h1>
        <div id="question-container"></div>
        <p id="question-count"></p>
        <button id="index-yes-btn" class="action-btn">Yes</button>
        <button id="index-no-btn" class="action-btn">No</button>
        <button id="index-back-btn" class="action-btn">Back</button>
        <button id="index-find-missing-btn" class="action-btn" onclick="window.location.href='/find_missing_values'">Find Missing Data Values</button>
        <button id="find-missing-yes-btn" class="action-btn">Provide Answer</button>
        <button id="find-missing-no-btn" class="action-btn">Next Question</button>
        <button id="find-missing-back-btn" class="action-btn">Back</button>
        <button id="show-flagged-values-btn" class="action-btn">Show Flagged Values Question</button>
        <button id="show-flagged-values-no-btn" class="action-btn">Next Question</button>
        <button id="show-flagged-values-back-btn" class="action-btn">Back</button>
        <button id="submit-answer-btn">Submit Answer</button>
    </div>
    <div id="queryModal" class="modal">
        <div class="modal-content">
            <span id="closeModal" class="close">&times;</span>
            <!-- <label>Provide an answer to the current question:</label> -->
            <p id="datatypeMessageContainer" style="color: rgb(0, 0, 0); margin-top: 35px;"></p>
            <input type="text" id="user-query-input" />
            <p id="error-message-container" class="error-message" style="display: none;"></p>
            <button id="submit-query-btn">Submit Your Answer</button>
        </div>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', function () {
        
        let displayedRowIdMissing; // Variable to store the displayed row ID for missing data questions
        let currentQuestionIndex = 0;
        let displayedRowId; // Variable to store the displayed row ID
        var preRenderedQuestions = {{ pre_rendered_questions | safe }};
        
        var generatedQueries = [];
        var currentUrl = window.location.href; // Get the current URL
        let totalQuestions = preRenderedQuestions.length;
        const inputField = document.getElementById('user-query-input');
        const submitQueryBtn = document.getElementById('submit-query-btn');
        const closeModalBtn = document.getElementById('closeModal');
        const modal = document.getElementById('queryModal');
        const userQueryInput = document.getElementById('user-query-input');

        closeModalBtn.addEventListener('click', function() {
        modal.style.display = 'none'; 
        userQueryInput.value = ''; 
        });

        const questionContainer = document.getElementById('question-container');
        const questionCount = document.getElementById('question-count');

        // Select buttons based on the current URL
        const yesBtn = document.getElementById('index-yes-btn');
        const noBtn = document.getElementById('index-no-btn');
        const backBtn = document.getElementById('index-back-btn');
        const findMissingBtn = document.getElementById('index-find-missing-btn');

        // Select buttons for the find_missing_values page
        const findMissingYesBtn = document.getElementById('find-missing-yes-btn');
        const findMissingNoBtn = document.getElementById('find-missing-no-btn');
        const findMissingBackBtn = document.getElementById('find-missing-back-btn');

        // Select buttons for the show_flagged_values page
        const flaggedValue = document.getElementById('show-flagged-values-btn');
        const flaggedValuesnoBtn = document.getElementById('show-flagged-values-no-btn');
        const flaggedValuesbackBtn = document.getElementById('show-flagged-values-back-btn');
        const submitAnswerBtn = document.getElementById('submit-answer-btn');

        // Check if on the find_missing_values page
        if (currentUrl.includes('/find_missing_values')) {
            // Hide buttons on the index page
            yesBtn.style.display = 'none';
            noBtn.style.display = 'none';
            backBtn.style.display = 'none';
            findMissingBtn.style.display = 'none';
            submitAnswerBtn.style.display = 'none';

            // Show buttons on the find_missing_values page
            findMissingYesBtn.style.display = 'inline-block';
            findMissingNoBtn.style.display = 'inline-block';
            findMissingBackBtn.style.display = 'inline-block';
            flaggedValuesnoBtn.style.display = 'none';
            flaggedValuesbackBtn.style.display = 'none';

        } else {
            // Show buttons on the index page
            yesBtn.style.display = 'inline-block';
            noBtn.style.display = 'inline-block';
            backBtn.style.display = 'inline-block';
            findMissingBtn.style.display = 'inline-block';

            // Hide buttons on the find_missing_values page
            findMissingYesBtn.style.display = 'none';
            findMissingNoBtn.style.display = 'none';
            findMissingBackBtn.style.display = 'none';
            submitAnswerBtn.style.display = 'none';
            flaggedValuesnoBtn.style.display = 'none';
            flaggedValuesbackBtn.style.display = 'none';
        }

        // Function to update the cursor style of the submit button
function updateSubmitButtonCursor() {
        if (inputField.value.trim() === '') {
            submitQueryBtn.classList.add('cursor-not-allowed');
            submitQueryBtn.disabled = true; // Optionally disable the button
        } else {
            submitQueryBtn.classList.remove('cursor-not-allowed');
            submitQueryBtn.disabled = false; // Optionally enable the button
        }
    }

    // Initial check in case there's already text in the input field when the page loads
updateSubmitButtonCursor();
    // Event listener to check input field's value on keyup
inputField.addEventListener('keyup', function () {
        updateSubmitButtonCursor();
    });

// Add an event listener to clear the error message when the user starts typing
inputField.addEventListener('input', function () {
    const errorMessageContainer = document.getElementById('error-message-container');
    errorMessageContainer.style.display = 'none';
    inputField.classList.remove('error');
});

document.getElementById('submit-query-btn').addEventListener('click', function(event) {
    event.preventDefault();
    
    // Reintegrate the error message container handling
    const errorMessageContainer = document.getElementById('error-message-container');
    errorMessageContainer.style.display = 'none'; // Hide any previous error messages
    userQueryInput.classList.remove('error'); 

    const userQuery = userQueryInput.value.trim();
    const currentQuestion = preRenderedQuestions[currentQuestionIndex];
    const expectedDatatype = currentQuestion.data.datatype;

    if (validateUserInput(userQuery, expectedDatatype)) {
        const dataToSend = {
            rowId: currentQuestion.data.row_id,
            mainColumn: currentQuestion.data?.mainColumn,
            relatedColumn: currentQuestion.data?.relatedColumn,
            answer: userQuery
        };

        sendDataToServer(dataToSend)
        .then(() => {
            closeModal(); // Close the modal after successful submission
            displayNextUnansweredQuestion(); // Adjusted to use the custom function for displaying the next question
        })
        .catch(error => {
            // Display error message in UI
            errorMessageContainer.innerText = error.message;
            errorMessageContainer.style.display = 'block';
            userQueryInput.classList.add('error');
            userQueryInput.value = ''; // Clear the input field
            userQueryInput.focus(); // Focus on the input field for the user to correct the input
        });
    } else {
        // Display error message for invalid input
        displayErrorMessage(`Invalid input. Please enter a valid ${expectedDatatype}.`);
    }
});

function displayNextUnansweredQuestion() {
    let nextIndex = currentQuestionIndex + 1; // Start searching from the next question
    while (nextIndex < totalQuestions && preRenderedQuestions[nextIndex].answered) {
        nextIndex++; // Skip already answered questions
    }

    if (nextIndex < totalQuestions) {
        currentQuestionIndex = nextIndex; // Update the current index to the next unanswered question
        displayQuestion(); // Display the next unanswered question
    } else {
        // If no more unanswered questions are found
        handleAllQuestionsAnswered();
    }
}

function displayErrorMessage(message) {
    const errorMessageContainer = document.getElementById('error-message-container');
    errorMessageContainer.innerText = message;
    errorMessageContainer.style.display = 'block';
    inputField.classList.add('error');
    inputField.value = ''; // Clear the input field
    inputField.focus(); // Focus on the input field for user to correct the input

    // Add a class to animate the input field
    inputField.classList.add('input-error-animation');
    // Remove the class after the animation completes to allow it to be triggered again if needed
    setTimeout(() => inputField.classList.remove('input-error-animation'), 600);
}

// Function to send data to the server
function sendDataToServer(dataToSend) {
    return fetch('/process_answers', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(dataToSend),
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Network response was not ok. Status: ' + response.status);
        }
        return response.json();
    })
    .then(data => {
        if (data.status === "success") {
            // Mark the current question as answered
            preRenderedQuestions[currentQuestionIndex].answered = true;
        } else {
            throw new Error(data.message);
        }
    })
    .catch(error => {
        console.error('Fetch error:', error);
        throw error; // Rethrow the error to be handled in the caller function
    });
}

function closeModal() {
    const modal = document.getElementById('queryModal');
    modal.style.display = 'none';
}

function showQuestionModal() {
    // Set up the submit query when showing the modal
    setUpSubmitQuery();
    modal.style.display = 'block';
}

function displayQuestion() {
    // Skip answered questions
    while (currentQuestionIndex < totalQuestions && preRenderedQuestions[currentQuestionIndex].answered) {
            currentQuestionIndex++;
        }

    if (currentQuestionIndex < totalQuestions) {
        const currentQuestion = preRenderedQuestions[currentQuestionIndex];
        console.log('Current question object:', currentQuestion);
        // Check if the data property exists on the current question
        if (currentQuestion.data) {
            console.log('Current Question Data:', currentQuestion.data);

            const datatype = currentQuestion.data.datatype || "appropriate";
            const mainColumn = currentQuestion.data.mainColumn; // Extracted mainColumn
            const relatedColumn = currentQuestion.data.relatedColumn; // Extracted relatedColumn

            console.log('Datatype:', datatype);
            console.log('Main Column:', mainColumn); // Log the extracted mainColumn
            console.log('Related Column:', relatedColumn); // Log the extracted relatedColumn
        } else {
            // If currentQuestion.data is undefined, handle the error or initialize it
            console.error('Current Question Data is undefined.');
            // Initialize currentQuestion.data or handle the lack of data appropriately
        }

        const datatype = currentQuestion.data && currentQuestion.data.datatype ? currentQuestion.data.datatype : "appropriate";
        console.log('Datatype:', datatype);
        const datatypeMessage = `The answer is expected to be in ${datatype} format.`;
        document.getElementById('datatypeMessageContainer').innerText = datatypeMessage;
        
        // Check if we are on the "find missing values" page and set displayedRowIdMissing
        if (currentUrl.includes('/find_missing_values')) {
            // Check if currentQuestion has a data property and a row_id within it
            if (currentQuestion.data && 'row_id' in currentQuestion.data) {
                displayedRowIdMissing = currentQuestion.data.row_id;
                console.log(`Currently Displayed Row ID (Missing Data): ${displayedRowIdMissing}`);
            } else {
                console.error('Row ID missing in question data for missing values page');
            }
        } else {
            // For other pages, use the existing method to set displayedRowId
            displayedRowId = currentQuestion.row_id;
            console.log(`Currently Displayed Row ID: ${displayedRowId}`);
        }

        // Determine whether we're dealing with a flagged value question or not
        if (currentQuestion.hasOwnProperty('question')) {
            // For flagged value questions
            questionContainer.innerHTML = `<label>${formatQuestionText(currentQuestion.question)}</label>`;
        } else {
            // For other question types (assuming 'message' field contains the question text)
            questionContainer.innerHTML = `<label>${formatQuestionText(currentQuestion.message)}</label>`;
        }

        // Add tooltip for rule violation text if it exists
        if (currentQuestion.hasOwnProperty('rule_violation') && currentQuestion.rule_violation) {
            const ruleViolationText = currentQuestion.rule_violation;
            const tooltip = document.createElement('img');
            tooltip.src = 'http://localhost/project/templates/info.png';
            tooltip.className = 'tooltip-icon';
            tooltip.alt = 'Info';
            tooltip.title = ruleViolationText; // Tooltip text
            const questionLabel = questionContainer.querySelector('label');
            questionLabel.appendChild(tooltip);
        }

        updateQuestionCount();
        // Ensure the submit button cursor and disabled state are updated for the new question
        updateSubmitButtonCursor();
    
        // Check if this is the last question
    if (currentQuestionIndex === totalQuestions - 1) {
            showLastQuestionNotification(); // Call a function to display a notification
        }
    
    } else {
        //alert('All questions answered. Submitting form...');
        handleAllQuestionsAnswered();
    }
}

function formatQuestionText(questionText) {
                return questionText.replace(/''/g, '_______');
            }

function updateQuestionCount() {
    const unansweredQuestions = preRenderedQuestions.filter(question => !question.answered).length;
    const currentQuestionNumber = preRenderedQuestions.slice(0, currentQuestionIndex).filter(question => !question.answered).length + 1; // Adjusted to reflect the current position

    questionCount.textContent = `Question ${currentQuestionNumber} of ${unansweredQuestions}`;
}

function submitAnswer() {
    
    const userQuery = userQueryInput.value.trim();
    const expectedDatatype = preRenderedQuestions[currentQuestionIndex].data.datatype;

    // Validate user input
    if (!validateUserInput(userQuery, expectedDatatype)) {
        displayErrorMessage(`Invalid input. Please enter a valid ${expectedDatatype}.`);
        return; // Prevent form submission
    }

    // If the input is valid, prepare the data for submission
    if (userQuery !== '') {
        const currentQuestion = preRenderedQuestions[currentQuestionIndex];
        const dataToSend = {
            rowId: currentQuestion.data.row_id,
            mainColumn: currentQuestion.data.mainColumn,
            relatedColumn: currentQuestion.data.relatedColumn,
            answer: userQuery
        };

        // Send the data to the server
        sendDataToServer(dataToSend, function (success) { // Pass a callback function for success
            if (success) {
                // Clear the input field only after successful submission
                userQueryInput.value = '';
                // Move to the next question or end the questionnaire
                currentQuestionIndex++;
                if (currentQuestionIndex < totalQuestions) {
                    displayQuestion();
                } else {
                    //alert('All questions answered. Submitting form...');
                    handleAllQuestionsAnswered();
                }
            }
        });
    }
}

// This function is called when the 'Yes' button is clicked on the index page
function answerYes_index() {
    modal.style.display = 'block'; // Show the modal
    // Add event listener to the close button of the modal
    closeModalBtn.addEventListener('click', function() {
        modal.style.display = 'none'; // Hide the modal
    });
}

function validateUserInput(input, datatype) {
    // Use regular expressions to test the input based on the expected datatype
    const regexPatterns = {
        'integer': /^\d+$/, // Matches a sequence of digits (no decimal)
        'float': /^\d+(\.\d+)?$/, // Matches a floating point number (integer part plus optional decimal part)
        'date': /^\d{4}-\d{2}-\d{2}$/, // Matches a simple YYYY-MM-DD date format
        'text': /^(?=.*[A-Za-z0-9])[A-Za-z0-9@.]+$/ // Requires at least one alphanumeric character, allows '@' and '.' for emails
    };

    // Check if the datatype is known and the pattern exists
    if (regexPatterns.hasOwnProperty(datatype)) {
        // Test the input against the corresponding regex pattern
        return regexPatterns[datatype].test(input);
    } else {
        // If the datatype is unknown, log an error and return false
        console.error(`Unknown datatype '${datatype}' for validation.`);
        return false;
    }
}

function findMissingPageAnswerYes() {
    modal.style.display = 'block';
    
}

// Function to update the database with the provided answer
function updateDatabaseWithAnswer(userQuery, currentQuestion) {
                const [_, rowId, mainColumn, relatedColumn] = currentQuestion.name.split('_');

                // Dynamically extract the relatedColumn from the question text
                const questionText = currentQuestion.message;
                const relatedColumnMatch = questionText.match(/The (.*?):/);
                const dynamicRelatedColumn = relatedColumnMatch ? relatedColumnMatch[1].trim() : null;

                const data = {
                    rowId: rowId,
                    mainColumn: mainColumn,
                    relatedColumn: dynamicRelatedColumn, // Use the dynamically extracted relatedColumn
                    answer: userQuery,
                };

                // Send a POST request to the server to process the answer and update the database
                fetch('/process_answers', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(data),
                })
                .then(response => response.json())
                .then(data => {
                    console.log(data);

                    // Increment the currentQuestionIndex and display the next question
                    currentQuestionIndex++;
                    if (currentQuestionIndex < totalQuestions) {
                        displayQuestion();
                    } else {
                        //alert('All questions answered. Submitting form...');
                        handleAllQuestionsAnswered();
                    }
                })
                .catch(error => console.error(error));
}

function answerNo_index() {
    const currentQuestion = preRenderedQuestions[currentQuestionIndex];

    // Send a POST request to the server to log the current row ID
    fetch('/log_current_row_id', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ row_id: currentQuestion.row_id }),  // Pass the current question's row_id
    })
    .then(response => response.json())
    .then(data => {
        // Move to the next question
        currentQuestionIndex++;

        // Check if there are more questions before displaying
        if (currentQuestionIndex < totalQuestions) {
            displayQuestion();
        } else {
            //alert('All questions answered. Submitting form...');
            handleAllQuestionsAnswered();
        }
    })
    .catch(error => console.error(error));
}

function findMissingPageAnswerNo() {
    currentQuestionIndex++;
    if (currentQuestionIndex < totalQuestions) {
        displayQuestion();
        console.log(`Missing Page Answer No : ${displayedRowIdMissing}`);
    } else {
        //alert('All questions answered. Submitting form...');
        handleAllQuestionsAnswered();
    }
}

function goBack_index() {
                    currentQuestionIndex--;
                    if (currentQuestionIndex >= 0) {
                        displayQuestion();
                    } else {
                        alert('No more previous questions.');
                        currentQuestionIndex = 0;
                    }
                }
                
function findMissingPageGoBack() {
    // Decrement index and skip answered questions
    do {
        currentQuestionIndex--;
    } while (currentQuestionIndex >= 0 && preRenderedQuestions[currentQuestionIndex].answered);

    if (currentQuestionIndex >= 0) {
        displayQuestion();
    } else {
        alert('No more previous questions.');
        currentQuestionIndex = 0; // Reset to the first question if needed
    }
}
                
function findMissingValues() {
                const filteredMissingQuestions = preRenderedQuestions.filter(question => {
                    const mainColumn = question.message.split("'")[1];
                    const mainColumnValue = row[mainColumn];
                    return mainColumnValue === '';
                });

                console.log('Filtered Missing Questions:', filteredMissingQuestions);

                totalQuestions = filteredMissingQuestions.length;

                if (totalQuestions > 0) {
                    currentQuestionIndex = 0;
                    preRenderedQuestions = filteredMissingQuestions;
                    findMissingBtn.disabled = true;
                    displayQuestion();
                } else {
                    questionContainer.innerHTML = '<p>No missing data questions found.</p>';
                    questionCount.textContent = '0 of 0';
                }

                updateGeneratedQueries();
            }
            
function showFlaggedValuesQuestions() {
    console.log('Show Flagged Values button clicked');
    // Make an AJAX request to fetch flagged values questions
    fetch('/show_flagged_values_questions', {
        method: 'GET',
        headers: {
            'Content-Type': 'application/json',
        },
    })
    .then(response => response.json())
    .then(data => {
        const flaggedValuesQuestions = data.questions;
        // Update the question container with flagged values questions
        questionContainer.innerHTML = ''; // Clear existing content
        // Iterate through flagged values questions and append to the question container
        flaggedValuesQuestions.forEach(question => {
            const questionElement = document.createElement('p');
            questionElement.textContent = question;
            questionContainer.appendChild(questionElement);
        });
        // Hide other buttons on the flagged values page
        yesBtn.style.display = 'none';
        noBtn.style.display = 'none';
        backBtn.style.display = 'none';
        findMissingBtn.style.display = 'none';
        findMissingYesBtn.style.display = 'none';
        findMissingNoBtn.style.display = 'none';
        findMissingBackBtn.style.display = 'none';
        submitAnswerBtn.style.display = 'inline-block';
    })
    .catch(error => console.error(error));
}

// Function to handle button clicks on the index page
function handleIndexPageButtonClick(buttonId) {
                if (buttonId === 'yes') {
                    answerYes_index();
                } else if (buttonId === 'no') {
                    answerNo_index();
                } else if (buttonId === 'back') {
                    goBack_index();
                }
            }

function handleFindMissingPageButtonClick(buttonId) {
            // Function for handling button clicks on the find_missing_values page
            if (buttonId === 'yes') {
                findMissingPageAnswerYes();
            } else if (buttonId === 'no') {
                findMissingPageAnswerNo();
            } else if (buttonId === 'back') {
                findMissingPageGoBack();
            }
        }
            
// Function to handle button click on the flagged values page
function handleFlaggedValuesButtonClick(buttonId) {
    if (buttonId === 'submit-answer') {
        console.log('Submitting flagged values answers');
    }
}

//Event listener for the 'Submit Answer' button on flagged values page
document.getElementById('submit-answer-btn').addEventListener('click', function () {
    console.log('Submit button clicked');
    handleFlaggedValuesButtonClick('submit-answer');
});

// Event listener for the 'Show Flagged Values' button
document.getElementById('show-flagged-values-btn').addEventListener('click', function() {
    fetch('/show_flagged_values_questions', {
        method: 'GET',
        headers: {
            'Content-Type': 'application/json',
        },
    })
    .then(response => response.json())
    .then(data => {
        // Update to use the correct structure for the questions
        const flaggedValuesQuestions = data.questions.map(question => ({
            question: question.question, // Assuming 'question' contains the question text
            rule_violation: question.rule_violation, // Rule violation text
            name: `flagged_value_question_${question.row_id}`, // Unique identifier for each question
            row_id: question.row_id // Row ID if available
        }));

        // Update preRenderedQuestions with the new data
        preRenderedQuestions = flaggedValuesQuestions;
        // Reset the current question index and display the first question
        currentQuestionIndex = 0;
        displayQuestion();
    })
    .catch(error => console.error(error));

    // Hide other buttons and show necessary ones for flagged values questions
    yesBtn.style.display = 'none';
    noBtn.style.display = 'none';
    backBtn.style.display = 'none';
    findMissingBtn.style.display = 'none';
    findMissingYesBtn.style.display = 'none';
    findMissingNoBtn.style.display = 'none';
    findMissingBackBtn.style.display = 'none';
    flaggedValue.style.display = 'none';

    flaggedValuesnoBtn.style.display = 'inline-block';
    flaggedValuesbackBtn.style.display = 'inline-block';
    submitAnswerBtn.style.display = 'inline-block';
});

// Event listeners for index page buttons
document.getElementById('index-yes-btn').addEventListener('click', function () {
                handleIndexPageButtonClick('yes');
            });

document.getElementById('index-no-btn').addEventListener('click', function () {
                handleIndexPageButtonClick('no');
            });

document.getElementById('index-back-btn').addEventListener('click', function () {
                handleIndexPageButtonClick('back');
            });

document.getElementById('show-flagged-values-no-btn').addEventListener('click', function () {
                currentQuestionIndex++;
                if (currentQuestionIndex < preRenderedQuestions.length) {
                    displayQuestion();
                } else {
                    alert('All questions answered.');
                }
            });
            
document.getElementById('show-flagged-values-back-btn').addEventListener('click', function () {
                currentQuestionIndex--;
                if (currentQuestionIndex >= 0) {
                    displayQuestion();
                } else {
                    alert('No previous questions.');
                    currentQuestionIndex = 0; // Reset to the first question
                }
            });

// Event listeners for find_missing_values page buttons
findMissingYesBtn.addEventListener('click', function () {
                handleFindMissingPageButtonClick('yes');
            });

findMissingNoBtn.addEventListener('click', function () {
                handleFindMissingPageButtonClick('no');
            });

findMissingBackBtn.addEventListener('click', function () {
                handleFindMissingPageButtonClick('back');
            });

function handleAllQuestionsAnswered() {
    // Close the modal and clear the input field
    closeModal();
    userQueryInput.value = '';

    // Hide all existing buttons
    const buttons = document.querySelectorAll('button');
    buttons.forEach(button => button.style.display = 'none');

    // Display a completion message
    questionContainer.innerHTML = '<p class="completion-message">Thank you! You have answered all the questions.</p>';

    // Create the "Take me back to the Home Page" button
    const homeButton = document.createElement('button');
    homeButton.textContent = 'Take me back to the Home Page';
    homeButton.id = 'home-page-button';
    homeButton.className = 'action-btn'; // Reuse the action-btn class for styling
    homeButton.onclick = function() { window.location.href = 'http://127.0.0.1:5500/templates/homepage.html'; };
    
    // Append the new button to the container
    document.querySelector('.container').appendChild(homeButton);
}

function showLastQuestionNotification() {
    const notificationContainer = document.createElement('div');
    notificationContainer.textContent = "This is the last question";
    notificationContainer.className = 'last-question-notification'; // Use the class instead of inline styles

    // Append this notification to the question container or any other suitable place in your DOM
    questionContainer.appendChild(notificationContainer);

    // Optionally, remove the notification after a few seconds
    setTimeout(() => {
        notificationContainer.remove();
    }, 5000); // Adjust the time as needed
}

if (totalQuestions > 0) {
    displayQuestion();
    } else {
        alert('No questions found.');
            }
});
    </script>
</body>
</html>